<!DOCTYPE html>
<html class="ui-player">
	<head>
		<meta charset="UTF-8" />
		<style type="text/css">
			video::cue {				
				visibility: hidden;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript">
			jQuery = top.jQuery
		</script>
		<script type="text/javascript" src="assets/js/core/global.js"></script>
		<script type="text/javascript" src="assets/js/playback/hls.custom.js"></script>
		<video id="video"></video>
		<script type="text/javascript">
			var hls, video = document.getElementById('video'), player = jQuery(video)
			var recoverDecodingErrorDate, recoverSwapAudioCodecDate, recoverTimer = 0, mediaErrors = []
			function recover(hls) {
				console.log('RECOVER', hls, top.Playback.endpoint)
				var doReset = true;
				clearTimeout(recoverTimer)
				if(hls){
					doReset = false;
					window.onerror = () => {
						return true
					}
					hls.recoverMediaError()
					recoverTimer = setTimeout(() => {
						window.onerror = null;
					}, 3000)
				}
				if(doReset){
					reset()
				}
			}
			function watchTimeout(ct, cb, timeoutMs) {
				if(!cb){
					cb = reset;
				}
				if(!timeoutMs) {
					timeoutMs = 5000;
				}
				var timer = 0, ms = video.currentTime;
				timer = setTimeout(() => {
					if(ms == video.currentTime){
						cb()
					}
				}, timeoutMs)
				player.off('canplaythrough').one('canplaythrough', () => {
					clearTimeout(timer)
					if(ct){
						currentTime(ct)
					}
				})
			}
			function handleMediaError(hls) {
				var msg = '', now = performance.now(), ct = false;
				if(top.Playback.active){
					if(top.Playback.active.decoderOutputAppending) {
						try {
							ct = currentTime()
						} catch(e) {
							console.warn('Failed to get currentTime.')
						}
					}
					if(top.Playback.active.ignoreErrors) {
						return;
					}
				}
				if (!recoverDecodingErrorDate || (now - recoverDecodingErrorDate) > 3000) {
					recoverDecodingErrorDate = now;
					msg = "trying to recover from media Error ..."
					watchTimeout(ct)
					recover(hls) // ffmpeg slow response, commenting it and trusting on hls.js here
				} else {
					if (!recoverSwapAudioCodecDate || (now - recoverSwapAudioCodecDate) > 3000) {
						recoverSwapAudioCodecDate = now;
						msg = "trying to swap Audio Codec and recover from media Error ..."
						hls.swapAudioCodec()
						watchTimeout(ct)
						recover(hls)
					} else {
						msg = "cannot recover, last media error recovery failed ..."
						setTimeout(reset, 1000)
					}
				}
				console.warn(msg)
				top.Playback.reportError(msg, 'playback')
			}	
			function updateSource(){
				var endpoint = top.Playback.endpoint
				if(endpoint && endpoint.mimetype){
					top.jQuery(video).off() // discard events
					let src = endpoint.src, isHLS = endpoint.mimetype.toLowerCase().indexOf('mpegurl') != -1
					if(top.Playback.proxy.isSupported(src)){
						src = top.Playback.proxy.proxify(src)
					} else if(isHLS && isLocal(src)){
						src = top.Playback.proxyLocal.proxify(src)
					}
					console.log('CONNECT', src, type)
					if(isHLS){
						if(!hls){
							var hlsConfig = {
								debug: false,
								maxSeekHole: 30,
								maxBufferSize: 0,       // Highly recommended setting
								maxBufferHole: 10,
								maxBufferLength: 300,
								maxMaxBufferLength: '600s',
								maxFragLookUpTolerance: 0.04
							}
							hls = new Hls(hlsConfig)
							hls.on(Hls.Events.ERROR, (event, data) => {
								var msg = "Player error: " + data.type + " - " + data.details;
								if(data.details == 'bufferStalledError'){
									console.warn(msg, data)
									// handleMediaError(hls)
									// not fatal, dont neet to handle so
									// wait, the playback hangs even it not saying that it's a fatal error, watch to be sure
									setTimeout(() => {
										/*
										let fwd = video.currentTime < (video.duration - 2)
										console.warn(data.details, video.currentTime, '/', video.duration, fwd)
										if(fwd){ // if has buffer, should not have stopped, threat as playback error
											//	video.currentTime = video.currentTime + 2
											//} else {
											recover(hls)
										} else { // no buffer, wait a bit before to threat as error
										*/
										watchTimeout(null, () => {
											top.seemsSlow()
											watchTimeout(null, () => {
												recover(hls)
											})
										})
									}, 0)
								} else if (data.fatal) {
									console.error(msg, data)
									// reset()
									switch (data.type) {
										case Hls.ErrorTypes.MEDIA_ERROR:
											handleMediaError(hls)
											break;
										case Hls.ErrorTypes.NETWORK_ERROR:
											console.error("network error ...")
											handleMediaError(hls)
											break;
										default:
											console.error("unrecoverable error")
											reset()
											break;
									}
								} else {
									console.error(msg, data)
								} 
							})
							hls.on(Hls.Events.MANIFEST_PARSED, () => {
								video.play()
							})
							hls.on(Hls.Events.MEDIA_ATTACHED, () => {
								// console.error('ATTACHED', _src)        
								hls.loadSource(src)
							})
							hls.on(Hls.Events.MEDIA_DETACHED, () => {
								setTimeout(() => {
									if(video.paused && !hls){
										console.warn('DETACHED', top.traceback(), top.Playback.endpoint)
									}
								}, 100)
							})
							hls.attachMedia(video)
						} else {
							hls.loadSource(src)
						}
					} else {
						if(hls){						
							hls.destroy()
							hls = false;
						}
						video.pause()
						video.removeAttribute('src')
						var type = endpoint.mimetype.replaceAll('"', "'").split(';')[0]
						video.innerHTML = '<source type="'+ type +'" src=\''+endpoint.src+'\' />'
						video.load()
						video.play()
					}
					top.Playback.rebind()
				}
			}
			function ready(f){
				f()
			}
			function pause(){
				if(!paused()){
					video.pause()
				}
			}
			function unpause(){
				if(paused()){
					video.play()
				}
			}
			function paused(){
				return video.paused
			}
			function stop(){
				console.warn("STOP", top.traceback())
				video.pause()
				if(hls){
					hls.destroy()
					hls = null;
				}
			}
			function videoElement(){
				if(!video || !video.parentNode){
					reset()
				}
				return video;
			}
			function play(callback){
				video.play()
				if(callback){
					callback()
				}
			}
			function currentTime(s){
				if(s){
					video.currentTime = s; 
				}
				return video.currentTime;
			}
			function seek(s) {
				video.currentTime += s;
			}
			function reset() {
				if(top.Playback.endpoint){
					updateSource()
				} else {
					console.log('STOP')
					stop()
				}
			}	
			function init() {
				reset()
			}
		</script>
	</body>
</html>
